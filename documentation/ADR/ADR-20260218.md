# ADR-20260218: ML 파이프라인 및 시뮬레이션 엔진 위치 결정

## Status

**Accepted** (2026-02-18)

## Context

공장 MES 시스템의 시뮬레이션 엔진 프로젝트에서 다음 두 가지 주요 기능의 구현 위치를 결정해야 했습니다:

1. **ML 파이프라인**: 시뮬레이션 정보를 학습하고 운영 결과를 예측하는 기능
2. **시뮬레이션 엔진**: 공장 운영을 시뮬레이션하고 이벤트를 발생시키는 기능

이 프로젝트는 **포트폴리오 용도**로, 최소한의 노력으로 최대한의 결과를 내는 것이 목표입니다.

### 고려 사항

- **ML 파이프라인**:
  - 데이터 수집(Kafka consume) → 분석 → ML 학습/예측의 전체 플로우를 한 곳에서 보여주는 것이 포트폴리오에 유리
  - Python 기반의 데이터 처리 및 ML 라이브러리(scikit-learn, pandas 등) 활용 필요
  - 기존 `servers/pipeline` 프로젝트는 이미 Clean Architecture로 모듈화되어 있어 확장 용이

- **시뮬레이션 엔진**:
  - 시뮬레이션 제어 API(시작/정지/상태 조회) 제공 필요
  - Unity 클라이언트와의 통신을 고려한 일관된 API 제공
  - 이벤트 발생 후 Kafka로 publish하는 메시징 기능 필요
  - `DotnetEngine` 프로젝트 이름이 "엔진" 역할과 부합

## Decision

### ML 파이프라인: `servers/pipeline` 프로젝트의 하위 모듈로 구현

- **위치**: `servers/pipeline/src/` 내부에 ML 관련 모듈 추가
- **구조**:
  ```
  pipeline/
  ├── src/
  │   ├── domains/
  │   │   └── ml/              # ML 도메인 (모델 메타데이터, 예측 결과 VO)
  │   ├── pipelines/
  │   │   ├── ml_training_pipeline.py    # 학습 use case
  │   │   └── ml_prediction_pipeline.py  # 예측 use case
  │   └── workers/
  │       └── ml_training_worker.py      # 주기적 학습 스케줄러
  ```
- **이유**:
  - 기존 데이터 파이프라인(Kafka consume → MongoDB 저장)과 동일한 프로젝트에서 관리
  - "데이터 수집 → 분석 → ML 학습 → 예측" 전체 플로우를 하나의 프로젝트로 보여줄 수 있음
  - 설정, 로깅, 예외 처리 등 공통 인프라 재사용 가능
  - 별도 프로젝트 생성/배포/문서화 부담 없음

### 시뮬레이션 엔진: `servers/backend` 프로젝트의 하위 모듈로 구현

- **위치**: `servers/backend/DotnetEngine/` 내부에 시뮬레이션 도메인/유스케이스 모듈 추가
- **구조**:
  ```
  backend/
  ├── DotnetEngine/
  │   ├── Domain/
  │   │   └── Simulation/      # 시뮬레이션 도메인 (엔티티, Value Object)
  │   ├── Application/
  │   │   └── Simulation/      # Use Case (RunSimulationCommand, GetSimulationState 등)
  │   └── Presentation/
  │       └── SimulationController.cs  # API 엔드포인트
  ```
- **이유**:
  - 프로젝트 이름 "DotnetEngine"이 시뮬레이션 엔진 역할과 부합
  - 시뮬레이션 제어 API를 기존 API 서버와 동일한 포트에서 제공 가능
  - Unity 클라이언트와의 통신을 백엔드 한 곳에서 관리하여 아키텍처 단순화
  - 시뮬레이션 상태 조회 및 제어를 REST API로 제공하기 용이

## Consequences

### 긍정적 영향

#### ML 파이프라인 (pipeline 프로젝트)
- ✅ 하나의 프로젝트에서 전체 데이터 플로우를 보여줄 수 있어 포트폴리오 가치 향상
- ✅ 기존 `domains/`, `pipelines/`, `workers/` 구조를 그대로 활용하여 확장 용이
- ✅ 설정, 로깅, 예외 처리 등 공통 인프라 재사용으로 개발 속도 향상
- ✅ 배포 및 문서화 부담 최소화

#### 시뮬레이션 엔진 (backend 프로젝트)
- ✅ 시뮬레이션 제어 API와 Unity 연동 API를 같은 서버에서 제공하여 아키텍처 단순화
- ✅ 기존 Layered + Hexagonal Architecture 패턴을 그대로 활용하여 일관성 유지
- ✅ Health 모듈과 동일한 패턴으로 확장 가능하여 학습 곡선 최소화

### 부정적 영향 및 완화 방안

#### ML 파이프라인 (pipeline 프로젝트)
- ⚠️ **프로젝트 크기 증가**: ML 모듈 추가로 프로젝트가 커질 수 있음
  - **완화**: 포트폴리오 용도이므로 프로젝트 크기 증가는 오히려 전체 플로우를 보여주는 데 유리
- ⚠️ **시뮬레이션 제어 API 부재**: ML 파이프라인에는 시뮬레이션을 시작/정지하는 API가 없음
  - **완화**: 시뮬레이션 제어는 backend에서 제공하므로 문제 없음

#### 시뮬레이션 엔진 (backend 프로젝트)
- ⚠️ **Kafka Producer 추가 필요**: 백엔드에 Kafka 클라이언트 라이브러리 추가 필요
  - **완화**: .NET용 Kafka 클라이언트(예: Confluent.Kafka) 라이브러리 추가로 해결 가능
- ⚠️ **시뮬레이션 로직 언어**: C#으로 시뮬레이션 로직을 작성해야 함
  - **완화**: 수식/통계 중심이 아닌 이벤트 발생 중심이라면 C#으로도 충분히 구현 가능

### 향후 고려 사항

- **시뮬레이션 엔진과 ML 파이프라인 간 통신**:
  - 시뮬레이션 엔진이 발생시킨 이벤트는 Kafka를 통해 ML 파이프라인이 consume
  - Kafka 토픽 설계 및 이벤트 스키마 정의 필요

- **확장성**:
  - 프로덕션 환경에서는 시뮬레이션 엔진과 ML 파이프라인을 별도 서비스로 분리 고려 가능
  - 현재는 포트폴리오 용도이므로 모듈 단위로 충분

## 참고

- [pipeline 프로젝트 구조](../pipeline/structure.md)
- [backend 프로젝트 README](../../servers/backend/README.md)
